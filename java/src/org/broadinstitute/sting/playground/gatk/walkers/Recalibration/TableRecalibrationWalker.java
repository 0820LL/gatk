package org.broadinstitute.sting.playground.gatk.walkers.Recalibration;

import net.sf.samtools.SAMRecord;
import net.sf.samtools.SAMFileWriter;
import org.broadinstitute.sting.gatk.walkers.ReadWalker;
import org.broadinstitute.sting.gatk.walkers.WalkerName;
import org.broadinstitute.sting.utils.cmdLine.Argument;
import org.broadinstitute.sting.utils.*;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;
import java.io.File;
import java.io.FileNotFoundException;

/**
 * Created by IntelliJ IDEA.
 * User: rpoplin
 * Date: Nov 3, 2009
 */

@WalkerName("TableRecalibrationRefactored")
public class TableRecalibrationWalker extends ReadWalker<SAMRecord, SAMFileWriter> {

    @Argument(fullName="recal_file", shortName="rf", doc="Input recalibration table file generated by CountCovariates", required=true)
    public String RECAL_FILE;
    @Argument(fullName="outputBam", shortName="outputBam", doc="output BAM file", required=false)
    public SAMFileWriter OUTPUT_BAM = null;
    @Argument(fullName="preserve_qscores_less_than", shortName="pQ", doc="If provided, bases with quality scores less than this threshold won't be recalibrated.  In general its unsafe to change qualities scores below < 5, since base callers use these values to indicate random or bad bases", required=false)
    public int PRESERVE_QSCORES_LESS_THAN = 5;
    @Argument(fullName = "use_original_quals", shortName="OQ", doc="If provided, we will use use the quals from the original qualities OQ attribute field instead of the quals in the regular QUALS field", required=false)
    public boolean USE_ORIGINAL_QUALS = false;
    @Argument(fullName="smoothing", shortName="sm", required = false, doc="Number of imaginary counts to add to each bin in order to smooth out bins with few data points")
    public int SMOOTHING = 1;

    public enum RecalibrationMode {
        COMBINATORIAL,
        SEQUENTIAL,
        ERROR
    }

    @Argument(fullName="RecalibrationMode", shortName="mode", doc="which type of calculation to use when recalibrating, default is SEQUENTIAL", required=false)
    public String MODE_STRING = RecalibrationMode.SEQUENTIAL.toString();
    public RecalibrationMode MODE = RecalibrationMode.SEQUENTIAL; //BUGBUG: need some code here to set this properly

    protected RecalDataManager dataManager;
    protected ArrayList<Covariate> requestedCovariates;

    private static Pattern COVARIATE_PATTERN = Pattern.compile("^@!.*");
    public final static String ORIGINAL_QUAL_ATTRIBUTE_TAG = "OQ";

    public void initialize() {

        // Get a list of all available covariates
        List<Class<? extends Covariate>> classes = PackageUtils.getClassesImplementingInterface(Covariate.class);

        int lineNumber = 0;
        boolean foundAllCovariates = false;
        dataManager = new RecalDataManager();

        // Read in the covariates that were used from the input file
        requestedCovariates = new ArrayList<Covariate>();


        // Read in the data from the csv file and populate the map
        out.print( "Reading in the data from input file..." );

        try {
            for ( String line : new xReadLines(new File( RECAL_FILE )) ) {
                lineNumber++;
                if ( COVARIATE_PATTERN.matcher(line).matches() ) { // the line string is either specifying a covariate or is giving csv data
                    if( foundAllCovariates ) {
                        throw new StingException( "Malformed input recalibration file. Found covariate names intermingled with data. " + RECAL_FILE );
                    } else { // found another covariate in input file
                        boolean foundClass = false;
                        for( Class<?> covClass : classes ) {

                            if( line.equalsIgnoreCase( "@!" + covClass.getSimpleName() ) ) { // the "@!" was added by CovariateCounterWalker as a code to recognize covariate class names
                                foundClass = true;
                                try {
                                    Covariate covariate = (Covariate)covClass.newInstance();
                                    requestedCovariates.add( covariate );
                                } catch ( InstantiationException e ) {
                                    throw new StingException( String.format("Can not instantiate covariate class '%s': must be concrete class.", covClass.getSimpleName()) );
                                } catch ( IllegalAccessException e ) {
                                    throw new StingException( String.format("Can not instantiate covariate class '%s': must have no-arg constructor.", covClass.getSimpleName()) );
                                }
                            }
                        }

                        if( !foundClass ) {
                            throw new StingException( "Malformed input recalibration file. The requested covariate type (" + line + ") isn't a valid covariate option." );
                        }

                    }

                }
                else { // found some data
                    if( !foundAllCovariates ) {
                        foundAllCovariates = true;
                        logger.info( "The covariates being used here: " );
                        logger.info( requestedCovariates );
                    }
                    addCSVData(line);
                }
            }

        } catch ( FileNotFoundException e ) {
            Utils.scareUser("Can not find input file: " + RECAL_FILE);
        } catch ( NumberFormatException e ) {
            throw new RuntimeException("Error parsing recalibration data at line " + lineNumber, e);
        }
        out.println( "...done!" );

        if( MODE == RecalibrationMode.SEQUENTIAL ) {
            out.print( "Creating collapsed tables for use in sequential calculation..." );
            dataManager.createCollapsedTables( requestedCovariates.size() );
            out.println( "...done!" );
        }
        
        //System.out.println(dataManager.getCollapsedTable(1));
    }

    private void addCSVData(String line) {
        String[] vals = line.split(",");
        ArrayList<Comparable<?>> key = new ArrayList<Comparable<?>>();
        Covariate cov; // preallocated for use in for loop below
        int iii;
        for( iii = 0; iii < requestedCovariates.size(); iii++ ) {
            cov = requestedCovariates.get( iii );
            key.add( cov.getValue( vals[iii] ) );
        }
        RecalDatum datum = new RecalDatum( Long.parseLong( vals[iii] ), Long.parseLong( vals[iii + 1] ) );
        dataManager.data.put( key, datum );
    }

    public SAMRecord map( char[] refBases, SAMRecord read ) {

        byte[] originalQuals = read.getBaseQualities();
        // Check if we need to use the original quality scores instead
        if ( USE_ORIGINAL_QUALS && read.getAttribute(ORIGINAL_QUAL_ATTRIBUTE_TAG) != null ) {
            Object obj = read.getAttribute(ORIGINAL_QUAL_ATTRIBUTE_TAG);
            if ( obj instanceof String )
                originalQuals = QualityUtils.fastqToPhred((String)obj);
            else {
                throw new RuntimeException(String.format("Value encoded by %s in %s isn't a string!", ORIGINAL_QUAL_ATTRIBUTE_TAG, read.getReadName()));
            }
        }
        byte[] recalQuals = originalQuals.clone();

        // For each base in the read
        Comparable<?> keyElement; // preallocate for use in for loops below
        for( int iii = 1; iii < read.getReadLength() - 1; iii++ ) { // skip first and last base because there is no dinuc
            ArrayList<Comparable<?>> key = new ArrayList<Comparable<?>>();
            boolean badKey = false;
            for( Covariate covariate : requestedCovariates ) {
                keyElement = covariate.getValue( read, iii, refBases );
                if ( keyElement != null ) {
                    key.add( keyElement );
                } else {
                    badKey = true;
                }
            }

            if( !badKey ) {
                if( MODE == RecalibrationMode.COMBINATORIAL ) {
                    RecalDatum datum = dataManager.data.get( key );
                    if( datum != null ) { // if we have data for this combination of covariates then recalibrate the quality score otherwise do nothing
                        recalQuals[iii] = datum.empiricalQualByte( SMOOTHING );
                    }
                } else if( MODE == RecalibrationMode.SEQUENTIAL ) {
                    recalQuals[iii] = performSequentialQualityCalculation( key );
                } else {
                    throw new StingException( "Specified RecalibrationMode is not supported: " + MODE );
                }

                // Do some error checking on the new quality score
                if ( recalQuals[iii]  <= 0 || recalQuals[iii]  > QualityUtils.MAX_REASONABLE_Q_SCORE ) {
                    throw new StingException( "Assigning bad quality score " + key + " => " +  recalQuals[iii] );
                }
            }
        }

        preserveQScores( originalQuals, recalQuals ); // overwrite the work done if original quality score is too low
        read.setBaseQualities(recalQuals); // overwrite old qualities with new recalibrated qualities
        if ( read.getAttribute(ORIGINAL_QUAL_ATTRIBUTE_TAG) == null ) { // save the old qualities if there is room in the read
            read.setAttribute(ORIGINAL_QUAL_ATTRIBUTE_TAG, QualityUtils.phredToFastq(originalQuals));
        }

        return read;
    }

    private byte performSequentialQualityCalculation( ArrayList<? extends Comparable<?>> key ) {

        byte qualFromRead = Byte.parseByte(key.get(1).toString());
        ArrayList<Comparable<?>> newKey;
        
        newKey = new ArrayList<Comparable<?>>();
        newKey.add( key.get(0) ); // read group
        RecalDatum globalDeltaQDatum = dataManager.getCollapsedTable(0).get( newKey );
        double globalDeltaQ = 0.0;
        double aggregrateQreported = 0.0;
        if( globalDeltaQDatum != null ) {
        	aggregrateQreported = QualityUtils.phredScaleErrorRate( dataManager.dataSumExpectedErrors.get( newKey ) / ((double) globalDeltaQDatum.getNumObservations()) );
           globalDeltaQ = globalDeltaQDatum.empiricalQualDouble( SMOOTHING ) - aggregrateQreported;
        }
        
       
        newKey = new ArrayList<Comparable<?>>();
        newKey.add( key.get(0) ); // read group
        newKey.add( key.get(1) ); // quality score
        RecalDatum deltaQReportedDatum = dataManager.getCollapsedTable(1).get( newKey );
        double deltaQReported = 0.0;
        if( deltaQReportedDatum != null ) {
            deltaQReported = deltaQReportedDatum.empiricalQualDouble( SMOOTHING ) - qualFromRead - globalDeltaQ;
        }
        
        
        double deltaQCovariates = 0.0;
        RecalDatum deltaQCovariateDatum;
        for( int iii = 2; iii < key.size(); iii++ ) {
            newKey = new ArrayList<Comparable<?>>();
            newKey.add( key.get(0) ); // read group
            newKey.add( key.get(1) ); // quality score
            newKey.add( key.get(iii) ); // given covariate
            deltaQCovariateDatum = dataManager.getCollapsedTable(iii).get( newKey );
            if( deltaQCovariateDatum != null ) {
                deltaQCovariates += ( deltaQCovariateDatum.empiricalQualDouble( SMOOTHING ) - qualFromRead - (globalDeltaQ + deltaQReported) );
            }
        }

        double newQuality = qualFromRead + globalDeltaQ + deltaQReported + deltaQCovariates;
        byte newQualityByte = QualityUtils.boundQual( (int)Math.round(newQuality), QualityUtils.MAX_REASONABLE_Q_SCORE );
        
        if( newQualityByte <= 0 && newQualityByte >= QualityUtils.MAX_REASONABLE_Q_SCORE ) {
            throw new StingException( "Illegal base quality score calculated: " + key +
                        String.format( " => %d + %.2f + %.2f + %.2f = %d", qualFromRead, globalDeltaQ, deltaQReported, deltaQCovariates, newQualityByte ) );
        }
        return newQualityByte;
    }

    private void preserveQScores( byte[] originalQuals, byte[] recalQuals ) {
        for( int iii = 0; iii < recalQuals.length; iii++ ) {
            if ( originalQuals[iii] < PRESERVE_QSCORES_LESS_THAN ) {
                recalQuals[iii] = originalQuals[iii];
            }
        }
    }

    public SAMFileWriter reduceInit() {
        return OUTPUT_BAM;
    }

    public SAMFileWriter reduce( SAMRecord read, SAMFileWriter output ) {
        if ( output != null ) {
            output.addAlignment(read);
        } else {
            out.println(read.format());
        }

        return output;
    }
}
